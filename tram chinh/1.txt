

#include <mega128a.h>

// I2C Bus functions
#include <i2c.h>

// DS1307 Real Time Clock functions
#include <ds1307.h>

// Graphic Display functions
#include <glcd.h>
#include <delay.h>
#include <string.h>

// Font used for displaying text
// on the graphic display
#include <font5x7.h>

#define IP "184.106.153.149"     // thingspeak.com
#define SSID "hunter"
#define PASS "1234567899"

#define bt_menu PINC.3
#define bt_enter PINC.0
#define bt_back PINC.2

const int BUFFSIZE = 400, TIME_LOOP_S = 120;

long i = 0, time_flow = 0;
int j,k = 0;
char cmd[4];
char buff[BUFFSIZE],la[20],lo[20], sms_command[8], gprs_command[6], entry_id[4], entry_id_old[6];
bool new_sms = false, notified = false, stop = false, send_ok = false, loop = false;
unsigned char ok[6]={0x0D,0x0A,0x4F,0x4B,0x0D,0x0A}, index=0;
unsigned char check_ok=0;
long dem;

int pr_back = -1, time_s = 0;

//value for uart 1
bool stop_1 = false, new_sms_1 = false, notified_1 = false, send_ok_1 = false;
char gprs_command_1[6], entry_id_1[4];
int i_1, j_1, k_1;
char buff_1[BUFFSIZE];


void push(char x) {
    int i = 0;
    for (i = 0; i < 4; i++) {
        cmd[i] = cmd[i+1];
    }
                
    cmd[3] = x;

}

void del_string(unsigned char *s) {
    while (*s) {
        *s = '\0';
        s++;
    }
}

int compare(unsigned char *s1, unsigned char *s2) {
    //compare hoi ngu nhung van chay duoc thoi ke no
    int i = 0;
    for (i = 0; i < 5; i++) {
        if (*s1 != *s2) return 0;
        s1++;
        s2++;
        if ((*s2 == '')) break;
    }
    return 1;
}

void clrscr() 
{
    del_string(buff);        
    i = 0;
    glcd_clear();
    glcd_moveto(0,0);
}

void reverse(char *s)
{
    /* get range */
    char *start = s;
    char *end = start + strlen(s) - 1; /* -1 for \0 */
    char temp;
                
    /* skip null */
    if (s == 0)
    {
        return;
    }

    /* skip empty string */
    if (*s == 0)
    {
        return;
    }

    /* reverse */
    while (end > start)
    {
        /* swap */
        temp = *start;
        *start = *end;
        *end = temp;

        /* move */
        ++start;
        --end;
    }
}

void del_quote(char* str) {
    char *pr = str, *pw = str;
    while (*pr) {
        *pw = *pr++;
        pw += (*pw != '"');
    }
    *pw = '\0';
}


// Declare your global variables here
#define DATA_REGISTER_EMPTY (1<<UDRE0)
#define RX_COMPLETE (1<<RXC0)
#define FRAMING_ERROR (1<<FE0)
#define PARITY_ERROR (1<<UPE0)
#define DATA_OVERRUN (1<<DOR0)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0=0,rx_rd_index0=0;
#else
unsigned int rx_wr_index0=0,rx_rd_index0=0;
#endif

#if RX_BUFFER_SIZE0 < 256
unsigned char rx_counter0=0;
#else
unsigned int rx_counter0=0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char status,data;
bool id_found = false;
status=UCSR0A;
data=UDR0;
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer0[rx_wr_index0++]=data;  
   if(data!=ok[index]) {index=0;check_ok=0;}
   else index++;
   if((ok[index-1]==0x0A)||(ok[index]==0x0A)||(ok[index-2]==0x0A)){check_ok=1;}
   else check_ok=0;  
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
   if (++rx_counter0 == RX_BUFFER_SIZE0)
      {
      rx_counter0=0;
      rx_buffer_overflow0=1;
      }
#endif
   }  
       buff[i] = data;
                
    if (data == ']') {
        stop = true;
    }
                
    if (buff[i] == 'I') {
        if (buff[i - 1] == 'T') {
            if (buff[i - 2] == 'M') {
                if (buff[i - 3] == 'C') {
                    new_sms = true;
                    notified = false;
                }
            }
        }
    }
                
    if (buff[i] == ']') {
        //"entry_id":15,"field1":"info"}]
        j = i - 2;
        k = 0;
        while (1) {
            if (j < 0) {
                j += BUFFSIZE;
            }
                        
            gprs_command[k] = buff[j - k];
            k++;        
            if ((buff[j - k] == '"')) {
                break;
            }
        } 
                    
        while (!id_found) {
            if ((buff[j] == 'i') && (buff[j+1] == 'd')) {
                k = 0;
                j = j + 4;
                while (buff[j] != ',') {
                    entry_id[k] = buff[j];
                    j++;
                    k++;
                }
                id_found = true;
            }
            j--;
        }
    }
                
    if (buff[i] == 'e') {
        if (buff[i - 1] == 'd') {
            if (buff[i - 2] == 'a') {
                if (buff[i - 3] == 'e') {
                    send_ok = true;
                }
            }
        }
    }
                
    i++;
    if (i > BUFFSIZE) {
        i = 0;
    }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter0==0);
data=rx_buffer0[rx_rd_index0++];
#if RX_BUFFER_SIZE0 != 256
if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
#endif
#asm("cli")
--rx_counter0;
#asm("sei")
return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0=0,tx_rd_index0=0;
#else
unsigned int tx_wr_index0=0,tx_rd_index0=0;
#endif

#if TX_BUFFER_SIZE0 < 256
unsigned char tx_counter0=0;
#else
unsigned int tx_counter0=0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
if (tx_counter0)
   {
   --tx_counter0;
   UDR0=tx_buffer0[tx_rd_index0++];
#if TX_BUFFER_SIZE0 != 256
   if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
while (tx_counter0 == TX_BUFFER_SIZE0);
#asm("cli")
if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer0[tx_wr_index0++]=c;
#if TX_BUFFER_SIZE0 != 256
   if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
#endif
   ++tx_counter0;
   }
else
   UDR0=c;
#asm("sei")
}
#pragma used-
#endif

// USART1 Receiver buffer
#define RX_BUFFER_SIZE1 32
char rx_buffer1[RX_BUFFER_SIZE1];

#if RX_BUFFER_SIZE1 <= 256
unsigned char rx_wr_index1=0,rx_rd_index1=0;
#else
unsigned int rx_wr_index1=0,rx_rd_index1=0;
#endif

#if RX_BUFFER_SIZE1 < 256
unsigned char rx_counter1=0;
#else
unsigned int rx_counter1=0;
#endif

// This flag is set on USART1 Receiver buffer overflow
bit rx_buffer_overflow1;

// USART1 Receiver interrupt service routine
interrupt [USART1_RXC] void usart1_rx_isr(void) {
    char status,data;
    bool id_found_1 = false;              
    status=UCSR1A;
    data=UDR1;
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0) {
        rx_buffer1[rx_wr_index1++]=data;
#if RX_BUFFER_SIZE1 == 256
        // special case for receiver buffer size=256
        if (++rx_counter1 == 0) rx_buffer_overflow1=1;
#else
        if (rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
        if (++rx_counter1 == RX_BUFFER_SIZE1) {
            rx_counter1=0;
            rx_buffer_overflow1=1;
        }
#endif
    }
             
           buff_1[i_1] = data;
                
    if (data == ']') {
        stop_1 = true;
    }
                
    if (buff_1[i_1] == 'I') {
        if (buff_1[i_1 - 1] == 'T') {
            if (buff_1[i_1 - 2] == 'M') {
                if (buff_1[i_1 - 3] == 'C') {
                    new_sms_1 = true;
                    notified_1 = false;
                }
            }
        }
    }
                
    if (buff_1[i_1] == ']') {
        //"entry_id":15,"field1":"info"}]
        j_1 = i_1 - 2;
        k_1 = 0;
        while (1) {
            if (j_1 < 0) {
                j_1 += BUFFSIZE;
            }
                        
            gprs_command_1[k_1] = buff_1[j_1 - k_1];
            k++;        
            if ((buff_1[j_1 - k_1] == '"')) {
                break;
            }
        } 
                    
        while (!id_found_1) {
            if ((buff_1[j_1] == 'i') && (buff_1[j_1+1] == 'd')) {
                k_1 = 0;
                j_1 = j_1 + 4;
                while (buff_1[j_1] != ',') {
                    entry_id_1[k_1] = buff_1[j_1];
                    j_1++;
                    k_1++;
                }
                id_found_1 = true;
            }
            j_1--;
        }
    }
                
    if (buff_1[i_1] == 'e') {
        if (buff_1[i_1 - 1] == 'd') {
            if (buff_1[i_1 - 2] == 'a') {
                if (buff_1[i_1 - 3] == 'e') {
                    send_ok_1 = true;
                }
            }
        }
    }
                
    i_1++;
    if (i_1 > BUFFSIZE) {
        i_1 = 0;
    }                
}

// Get a character from the USART1 Receiver buffer
#pragma used+
char getchar1(void)
{
char data;
while (rx_counter1==0);
data=rx_buffer1[rx_rd_index1++];
#if RX_BUFFER_SIZE1 != 256
if (rx_rd_index1 == RX_BUFFER_SIZE1) rx_rd_index1=0;
#endif
#asm("cli")
--rx_counter1;
#asm("sei")
return data;
}
#pragma used-
// USART1 Transmitter buffer
#define TX_BUFFER_SIZE1 8
char tx_buffer1[TX_BUFFER_SIZE1];

#if TX_BUFFER_SIZE1 <= 256
unsigned char tx_wr_index1=0,tx_rd_index1=0;
#else
unsigned int tx_wr_index1=0,tx_rd_index1=0;
#endif

#if TX_BUFFER_SIZE1 < 256
unsigned char tx_counter1=0;
#else
unsigned int tx_counter1=0;
#endif

// USART1 Transmitter interrupt service routine
interrupt [USART1_TXC] void usart1_tx_isr(void)
{
if (tx_counter1)
   {
   --tx_counter1;
   UDR1=tx_buffer1[tx_rd_index1++];
#if TX_BUFFER_SIZE1 != 256
   if (tx_rd_index1 == TX_BUFFER_SIZE1) tx_rd_index1=0;
#endif
   }
}

// Write a character to the USART1 Transmitter buffer
#pragma used+
void putchar1(char c)
{
while (tx_counter1 == TX_BUFFER_SIZE1);
#asm("cli")
if (tx_counter1 || ((UCSR1A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer1[tx_wr_index1++]=c;
#if TX_BUFFER_SIZE1 != 256
   if (tx_wr_index1 == TX_BUFFER_SIZE1) tx_wr_index1=0;
#endif
   ++tx_counter1;
   }
else
   UDR1=c;
#asm("sei")
}
#pragma used-

// Standard Input/Output functions
#include <stdio.h>

#define CE PORTA.3
#define CSN PORTA.2
#define SCK PORTA.4
#define MOSI PORTA.1
#define MISO PINA.5
#define IRQ PINA.0

unsigned char P_Add, Code_tay_cam1 = 0xA1, Code_tay_cam2 = 0xA2, Code_tay_cam3 = 0xA3, Code_tay_cam4 = 0xA4; 
#include <nrf_code.h>

#include <stdio.h>
#include <stdlib.h>

int count;

void print_border(){
    glcd_line(48,0, 48, 15);
    glcd_line(0, 15, 48, 15);
                    
    glcd_line(0,0,84,0);
    glcd_line(84,0, 84, 48);
    glcd_line(0, 48, 84, 48);
    glcd_line(0, 0, 0, 48);
    glcd_moveto(3,3);
    glcd_outtext("Node: ");
                        
    glcd_moveto(4, 18);
    glcd_outtext("Temp: ");
    glcd_moveto(4, 28);
    glcd_outtext("Humid: ");
    glcd_moveto(4, 37);
    glcd_outtext("Water: "); 
    glcd_moveto(67, 28);
    glcd_putchar(37);
    glcd_moveto(67, 37);
    glcd_outtext("mm");
}

void put_string (unsigned char *s) {
    while(*s) {
        putchar(*s);
        delay_ms(50);
        s++;
    }
}

void put_string_1(unsigned char *s){
    while(*s){
        putchar1(*s);
        delay_ms(50);
        s++;
    }
}

void refresh(int time_ms) {
    delay_ms(time_ms);

    //glcd_clear();
    //glcd_moveto(0,0);

    //glcd_outtext(buff);

    del_string(buff);    

    i = 0;

                

}

bool wait_until(unsigned char *keyword, int time_out_s) {
    /*     deu biet cai temp2 de lam gi nhung khong co thi no khong chay trong 1 so truong hop @@
        Vi du nhap vao "Hell" thi no se tach thua ra them 2 char. Co the do vi tri o nho. Cha biet @@*/
    char temp[20], temp2[20];
    int i = 0, time_start, time_temp;
                
    del_string(temp);
                
    while (*keyword) {
        temp[i] = *keyword;
        temp2[i] = temp[i];
        keyword++;
        i++;
    }
                
    time_start = time_s;
                
    while (1) {
        if (time_s < time_start) {
            time_temp = time_s + 60;
            if (time_temp - time_start > time_out_s) {
                //glcd_outtext("Timed out\r\n");
                return false;
                //break;
            }
        } else {
            if (time_s - time_start > time_out_s) {
                //glcd_outtext("Timed out\r\n");
                return false;
                //break;
            }
        }
                    
        if ((strstr(buff, temp)) || (strstr(buff, temp2))) {
            return true;
            //break;
        }
        if (strstr(buff, "ERROR")) {
            /*glcd_outtext("Error found, attempting to continue..\r\n");
            delay_ms(3000);
            glcd_clear();
            glcd_moveto(0,0);*/
            return false;
            //break;
            //nen lam them ve cai nay nua
        }
    }                  
    return false;
}

bool wait_until_1(unsigned char *keyword, int time_out_s) {
    char temp[20], temp2[20];
    int i = 0, time_start, time_temp;
                
    del_string(temp);
                
    while (*keyword) {
        temp[i] = *keyword;
        temp2[i] = temp[i];
        keyword++;
        i++;
    }
                
    time_start = time_s;
                
    while (1) {
        if (time_s < time_start) {
            time_temp = time_s + 60;
            if (time_temp - time_start > time_out_s) {
                //glcd_outtext("Timed out\r\n");
                return false;
            }
        } else {
            if (time_s - time_start > time_out_s) {
                return false;
            }
        }
                    
        if ((strstr(buff_1, temp)) || (strstr(buff_1, temp2))) {
            return true;
        }
        if (strstr(buff_1, "ERROR")) {
            return false;
        }
    }                    
    return false;
}

bool wifi_connect(){
    put_string("AT+CWMODE=1\r\n");
    if(!wait_until("OK", 2)){
        glcd_clear();
        glcd_moveto(0,0);
        glcd_outtext("config fail");
        return false;              
    }
    refresh(0);
                
    put_string("AT+CWJAP=\"Thay_Thao_deo_giai\",\"chinhxac\"\r\n");
    if(!wait_until("OK", 10)){
        glcd_clear();                
        glcd_moveto(0,0);
        glcd_outtext("connect fail");
        return false;           
    }          
    glcd_clear();                
    glcd_moveto(0,0);
    glcd_outtext("connect wifi success");
    delay_ms(1000);
    refresh(0);      
    return true;
}

bool read_and_send(unsigned char *s){
    // Thay nhung ham respones_read bang ham wait_until
    char api_key[20], cmd[] = "GET /update?key=", temp[20], temp2[20];
    int length = 0, i = 0;
                
    while (*s) {
        temp2[i] = *s;
        api_key[i] = temp2[i];
        s++;
        i++;
    }
             
    put_string("AT+CIPMUX=1");
    delay_ms(300);
    put_string("\r\n");
    if(!wait_until("OK", 2)){
        glcd_moveto(0,0);
        glcd_outtext("connect fail 1");
        return false;
    }
    refresh(0);
                
    put_string("AT+CIPSTART=0,\"TCP\",\"api.thingspeak.com\",80");
    delay_ms(300);
    put_string("\r\n");
    if(!wait_until("OK", 20)){
        glcd_moveto(0,0);
        glcd_outtext("connect fail 2");
        return false;
    }
    refresh(2000);
                
    strcat(cmd, temp2);
    strcat(cmd, "&field1=");
                
    itoa(station_receive.temp, temp);
                
    //itoa(200, temp);
    strcat(cmd, temp);
                
    strcat(cmd, "&field2=");
    itoa(station_receive.humi, temp);
   // itoa(200, temp);
    strcat(cmd, temp);
               
    strcat(cmd, "&field3=");
     itoa(station_receive.water, temp);
  //  itoa(200, temp);
    strcat(cmd, temp);
                
    strcat(cmd, "&field4=");
    strcat(cmd, la);
                
    strcat(cmd, "&field5=");
    strcat(cmd, lo);
                
    length = strlen(cmd);
    length += 2;
                
    itoa(length, temp);
                
    del_string(buff);
                
    put_string("AT+CIPSEND=0,");
    put_string(temp); 
    delay_ms(1000);
    put_string("\r\n");
                
    wait_until("> ", 5);
            
    put_string(cmd);
    put_string("\r\n");
    delay_ms(1000);
    putchar(0x1A);
                
    refresh(0);
    
    glcd_clear();
    glcd_moveto(0,0);
    glcd_outtext("send success");
    delay_ms(200);
    return true;
}

void gprs_init() {
                
    put_string("AT+CLIP=1\r");
    wait_until("OK", 2);
    // refresh(2000);
                
    put_string("AT&W\r");
    wait_until("OK", 2);
    // refresh(2000);
                
    // put_string("AT+CMGF=1\r");
    // refresh(500);
                
    // put_string("AT+CNMI=2,1,0,0,0\r");
    // refresh(500);
                
    // put_string("AT+CSAS\r");
    // refresh(500);
                
    put_string("AT+CIPMODE=0\r");
    wait_until("OK", 2);
    // refresh(2000);
                
    put_string("AT+CIPCSGP=1,\"m3-world\",\"mms\",\"mms\"\r");
    wait_until("OK", 3);
    // refresh(2000);
                
    put_string("AT+CIPHEAD=0\r");
    wait_until("OK", 2);
    // refresh(2000);
                
    put_string("AT+CIPSPRT=1\r");
    wait_until("OK", 2);
    // refresh(2000);
                
    put_string("AT+CIPSRIP=0\r");
    wait_until("OK", 2);
    // refresh(2000);
                
    put_string("AT+CIPSCONT\r");
    wait_until("OK", 2);
    // refresh(2000);
                
    // glcd_outtext("GPRS Initialization completed");
}

void sms_init() {
    char temp;
    int stop = 0;
                
    while(!stop) {
        put_string("AT+CCALR?\r");
        while (1) {
            temp = getchar();
            // glcd_putchar(temp);
            push(temp);
            if (compare(cmd, "R: 1")) {
                stop = 1;
                break;
            }
            if (temp == '\r') break;
            if (temp == '\n') break;
            if (temp == '') break;
        }
        delay_ms(3000);        
        // refresh(3000);        
    }
                
    put_string("AT+CMGF=1\r");
    wait_until("OK", 2);
    // refresh(2000);

    put_string("AT+CNMI=2,1,0,0,0\r");
    wait_until("OK", 2);
    // refresh(2000);

    put_string("AT+CSAS\r");
    wait_until("OK", 2);
    // refresh(2000);
}

void sms_send(unsigned char *s) {
    put_string("AT+CMGF=1\r");
    wait_until("OK", 2);
                    
    put_string("AT+CMGS=\"+84945615998\"\r");    
    wait_until("> ", 5);
    while (*s) {
        putchar(*s);
        delay_ms(50);
        s++;
    }
    putchar(0x1A);
                
    del_string(buff);
                
    i = 0;
                
    glcd_outtext("SMS sent\r\n");
                
                
}

void gprs_send(unsigned char *s1, unsigned char *s2) {
    glcd_outtext("Connecting...\r\n");

    put_string("AT+CIPSTART=\"TCP\",\"api.thingspeak.com\",80\r");
    wait_until("CONNECT OK", 20);
                
    glcd_outtext("Connected\r\n");
                
    put_string("AT+CIPSEND\r");
    wait_until("> ", 4);

    glcd_outtext("Sending data..\r\n");
                
    put_string("GET /update?api_key=MKUPZUITP8BJB6VB&field3=");
    while (*s1) {
        putchar(*s1);
        delay_ms(50);
        s1++;
    }
                
    put_string("&field4=");
    while (*s2) {
        putchar(*s2);
        delay_ms(50);
        s2++;
    }
    put_string(" HTTP/1.1\r\n");
                
    put_string("HOST: www.api.thingspeak.com\r\n");

    delay_ms(100);

    put_string("Connection: close\r\n\r\n");
                
    del_string(buff);

    putchar(0x1A);
                
    wait_until("OK", 10);
                
    glcd_outtext("Data sent\r\n");    
                
}

void decrypt(unsigned char *s) {
    char message[40], temp[6];
    int i = 0;
                
    while (*s) {
        temp[i] = *s;
        delay_ms(50);
        s++;
        i++;
    }
                
    if (compare(temp, "on1")) {
        PORTB.2 = 1;
        return;
    }    
                
    if (compare(temp, "on2")) {
        PORTB.3 = 1;
        return;
    }
                  
    if (compare(temp, "on")) {
        PORTB.2 = 1;
        PORTB.3 = 1;
        return;
    }
                
    if (compare(temp, "off1")) {
        PORTB.2 = 0;
        return;
    }
                
    if (compare(temp, "off2")) {
        PORTB.3 = 0;
        return;
    }
                
    if (compare(temp, "off")) {
        PORTB.2 = 0;
        PORTB.3 = 0;
        return;
    }
                
    if (compare(temp, "info")) {
        strcat(message, "Relay 1: ");
                    
        if (PORTB.2 == 1) {
            strcat(message, "on");
        } else {
            strcat(message, "off");
        }
                    
        strcat(message, "\r");
        strcat(message, "Relay 2: ");
                    
        if (PORTB.3 == 1) {
            strcat(message, " on");
        } else {
            strcat(message, " off");
        }
                    
        sms_send(message);
    }
}

void sms_read() {
                
    clrscr();
    put_string("AT+CMGR=1\r");
                
    wait_until("OK", 2);
                
    put_string("AT+CMGD=1\r");
                
    glcd_outtext("SMS from ");
                
    i = 0;
    while (buff[i] != '') {
        i++;
        if ((buff[i] == ',') && (buff[i+1] == '"')) {
            i+=2;
            while (buff[i] != '"') {
                glcd_putchar(buff[i]);
                i++;
            }
            break;
        }
    }
                
    glcd_outtext(":\r\n");
                    
    while (buff[i] != '') {
        i++;
        if ((buff[i] == '"') && (buff[i+1] == '\r')) {
            i += 3;            
            j = 0;
            while (buff[i-1] != '#') {
                glcd_putchar(buff[i]);
                sms_command[j] = buff[i];
                            
                i++;
                j++;
                            
                if ((buff[i] == 13) && (buff[i+1] == 10)) break;
            }
            decrypt(sms_command);
            break;
        }
    }
}

void gprs_read() {
                
    del_string(gprs_command);
    del_string(entry_id);
    del_string(buff);
                
    clrscr();
                
    glcd_outtext("Connecting..\r\n");
                
    put_string("AT+CIPSTART=\"TCP\",\"api.thingspeak.com\",80\r");
    wait_until("CONNECT OK", 20);
                
    glcd_outtext("Connected\r\n");
                
    put_string("AT+CIPSEND\r");
    wait_until("> ", 4);
                
    glcd_outtext("Getting command..\r\n");

    put_string("GET /channels/324191/fields/1.json?api_key=AW5F75UF54ZYPVPS&results=1000000 HTTP/1.1\r\n");
    delay_ms(100);
    // refresh(1000);

    put_string("HOST: www.api.thingspeak.com\r\n");
    delay_ms(100);
    // refresh(1000);

    put_string("Connection: close\r\n\r\n");

    putchar1(0x1A);
                
    glcd_outtext("Processing..");
                
    while(1) {
        if (stop) {
            glcd_clear();
            glcd_moveto(0,0);
            reverse(gprs_command);
            del_quote(gprs_command);
            break;
        }
    }
                
    glcd_outtext("Entry id: ");
    glcd_outtext(entry_id);
                
    glcd_outtext("\r\n");
                        
    glcd_outtext("Command: ");
    glcd_outtext(gprs_command);
    stop = false;
                
    glcd_outtext("\r\n");
                
    // put_string("AT+CIPSHUT\r");
                
    delay_ms(3000);
                
    if (compare(entry_id, entry_id_old)) {
        glcd_outtext("No new command\r\n");
    } else {
        decrypt(gprs_command);
    }
        delay_ms(3000);
                    
    memcpy(entry_id_old, entry_id, sizeof(entry_id_old));
                
}

bool gps_init(){
    put_string_1("AT+CGNSPWR=1\r");
    if(!wait_until_1("OK", 2)){
        glcd_clear();
        glcd_moveto(0,0);
        glcd_outtext("config gps fail");
        return false;        
    }
    put_string_1("AT+CGNSSEQ=RMC\r");
    if(!wait_until_1("OK", 2)){
        glcd_clear();
        glcd_moveto(0,0);
        glcd_outtext("connect gps fail");
        return false;        
    }                                
    glcd_clear();
    glcd_moveto(0,0);
    glcd_outtext("gps init success");
    delay_ms(1000);
    return true; 
}

void gps_read() {
    bool la1 = false, lo1 = false;
    int comma = 0;
                
    put_string_1("AT+CGNSINF\r");
    if(!wait_until_1("OK", 2))
        return;
                
    /*glcd_clear();
    glcd_moveto(0,0); */
    i = 0;
    while (comma < 5) {
        i++;
        if (buff[i] == ',') {
            comma++;
        }           
        if (comma == 3) { 
            if (!la1 ) {
                i++;
                k = 0;
            }
            la[k] = buff[i];
            k++;  
            la1 = true;
        }                         
        if (comma == 4) {
            if (!lo1) {
                i++;
                k = 0;
            }                        
            lo[k] = buff[i];
            k++;   
            lo1 = true;
        }
    }
                
    if (la[0] == ',') {
            del_string(la);
            strcat(la, "11");
    }
                
    if (lo[0] == ',') {
            del_string(lo);
            strcat(lo, "11");
    }
}

void data_send(char *cmd){
    put_string(cmd);
    delay_ms(300);
    putchar(13);
    //response_read();
}

interrupt [TIM0_OVF] void timer0_ovf_isr(void)
{
    TCNT0=0x60;
    // Place your code here
    time_flow++;
    if ((bt_back == 1) && (pr_back == 0)) {
        /*glcd_clear();
        glcd_moveto(0,0);
        glcd_outtext("Loop terminated\r\n"); */
        loop = false;
        PORTB.3 = 0;
    }
                
                
    if (time_flow == 50000) {
        time_s++;
        time_flow = 0;
    }
                
    if (time_s == TIME_LOOP_S) {
        time_s = 0;
        if (loop) {
            /*gprs_read();
            clrscr();
            gps_read();
            delay_ms(3000);
            clrscr();
            gprs_send(la, lo);*/
        }
                            
    }    
                
    pr_back = bt_back;

} 

interrupt[TIM2_OVF] void timer2_flow(){
    TCNT2 = 0x9C;
    dem++;
    if(dem == 40000){
        count++;     
        if(count == 5){
            count = 1;
        }
        dem = 0;     
        TCNT2 = 0x00;
    }
}


void main(void)
{
// Declare your local variables here
// Variable used to store graphic display
// controller initialization data
GLCDINIT_t glcd_init_data;

// Input/Output Ports initialization
// Port A initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRA=(0<<DDA7) | (1<<DDA6) | (0<<DDA5) | (1<<DDA4) | (1<<DDA3) | (1<<DDA2) | (1<<DDA1) | (0<<DDA0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTA=(0<<PORTA7) | (0<<PORTA6) | (1<<PORTA5) | (1<<PORTA4) | (1<<PORTA3) | (1<<PORTA2) | (1<<PORTA1) | (1<<PORTA0);

// Port B initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRB=(0<<DDB7) | (0<<DDB6) | (0<<DDB5) | (0<<DDB4) | (0<<DDB3) | (0<<DDB2) | (0<<DDB1) | (0<<DDB0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORTB1) | (0<<PORTB0);

// Port C initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRC=(0<<DDC7) | (0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTC=(0<<PORTC7) | (0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (1<<PORTC2) | (0<<PORTC1) | (1<<PORTC0);

// Port D initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRD=(0<<DDD7) | (0<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTD=(0<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (0<<PORTD3) | (0<<PORTD2) | (0<<PORTD1) | (0<<PORTD0);

// Port E initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRE=(0<<DDE7) | (0<<DDE6) | (0<<DDE5) | (0<<DDE4) | (0<<DDE3) | (0<<DDE2) | (0<<DDE1) | (0<<DDE0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTE=(0<<PORTE7) | (0<<PORTE6) | (0<<PORTE5) | (0<<PORTE4) | (0<<PORTE3) | (0<<PORTE2) | (0<<PORTE1) | (0<<PORTE0);

// Port F initialization
// Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRF=(0<<DDF7) | (0<<DDF6) | (0<<DDF5) | (0<<DDF4) | (0<<DDF3) | (0<<DDF2) | (0<<DDF1) | (0<<DDF0);
// State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTF=(0<<PORTF7) | (0<<PORTF6) | (0<<PORTF5) | (0<<PORTF4) | (0<<PORTF3) | (0<<PORTF2) | (0<<PORTF1) | (0<<PORTF0);

// Port G initialization
// Function: Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
DDRG=(0<<DDG4) | (0<<DDG3) | (0<<DDG2) | (0<<DDG1) | (0<<DDG0);
// State: Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T 
PORTG=(0<<PORTG4) | (0<<PORTG3) | (0<<PORTG2) | (0<<PORTG1) | (0<<PORTG0);

// Timer/Counter 0 initialization
// Clock source: System Clock
// Clock value: Timer 0 Stopped
// Mode: Normal top=0xFF
// OC0 output: Disconnected
ASSR=0<<AS0;
TCCR0=(0<<WGM00) | (0<<COM01) | (0<<COM00) | (0<<WGM01) | (0<<CS02) | (0<<CS01) | (1<<CS00);
TCNT0=0x60;
OCR0=0x00;

// Timer/Counter 1 initialization
// Clock source: System Clock
// Clock value: Timer1 Stopped
// Mode: Normal top=0xFFFF
// OC1A output: Disconnected
// OC1B output: Disconnected
// OC1C output: Disconnected
// Noise Canceler: Off
// Input Capture on Falling Edge
// Timer1 Overflow Interrupt: Off
// Input Capture Interrupt: Off
// Compare A Match Interrupt: Off
// Compare B Match Interrupt: Off
// Compare C Match Interrupt: Off
TCCR1A=(0<<COM1A1) | (0<<COM1A0) | (0<<COM1B1) | (0<<COM1B0) | (0<<COM1C1) | (0<<COM1C0) | (0<<WGM11) | (0<<WGM10);
TCCR1B=(0<<ICNC1) | (0<<ICES1) | (0<<WGM13) | (0<<WGM12) | (0<<CS12) | (0<<CS11) | (0<<CS10);
TCNT1H=0x00;
TCNT1L=0x00;
ICR1H=0x00;
ICR1L=0x00;
OCR1AH=0x00;
OCR1AL=0x00;
OCR1BH=0x00;
OCR1BL=0x00;
OCR1CH=0x00;
OCR1CL=0x00;

// Timer/Counter 2 initialization
// Clock source: System Clock
// Clock value: Timer2 Stopped
// Mode: Normal top=0xFF
// OC2 output: Disconnected
TCCR2=(0<<WGM20) | (0<<COM21) | (0<<COM20) | (0<<WGM21) | (0<<CS22) | (1<<CS21) | (0<<CS20);
TCNT2=0x00;
OCR2=0x00;

// Timer/Counter 3 initialization
// Clock source: System Clock
// Clock value: Timer3 Stopped
// Mode: Normal top=0xFFFF
// OC3A output: Disconnected
// OC3B output: Disconnected
// OC3C output: Disconnected
// Noise Canceler: Off
// Input Capture on Falling Edge
// Timer3 Overflow Interrupt: Off
// Input Capture Interrupt: Off
// Compare A Match Interrupt: Off
// Compare B Match Interrupt: Off
// Compare C Match Interrupt: Off
TCCR3A=(0<<COM3A1) | (0<<COM3A0) | (0<<COM3B1) | (0<<COM3B0) | (0<<COM3C1) | (0<<COM3C0) | (0<<WGM31) | (0<<WGM30);
TCCR3B=(0<<ICNC3) | (0<<ICES3) | (0<<WGM33) | (0<<WGM32) | (0<<CS32) | (0<<CS31) | (0<<CS30);
TCNT3H=0x00;
TCNT3L=0x00;
ICR3H=0x00;
ICR3L=0x00;
OCR3AH=0x00;
OCR3AL=0x00;
OCR3BH=0x00;
OCR3BL=0x00;
OCR3CH=0x00;
OCR3CL=0x00;

// Timer(s)/Counter(s) Interrupt(s) initialization
TIMSK=(0<<OCIE2) | (1<<TOIE2) | (0<<TICIE1) | (0<<OCIE1A) | (0<<OCIE1B) | (0<<TOIE1) | (0<<OCIE0) | (1<<TOIE0);
ETIMSK=(0<<TICIE3) | (0<<OCIE3A) | (0<<OCIE3B) | (0<<TOIE3) | (0<<OCIE3C) | (0<<OCIE1C);

// External Interrupt(s) initialization
// INT0: Off
// INT1: Off
// INT2: Off
// INT3: Off
// INT4: Off
// INT5: Off
// INT6: Off
// INT7: Off
EICRA=(0<<ISC31) | (0<<ISC30) | (0<<ISC21) | (0<<ISC20) | (0<<ISC11) | (0<<ISC10) | (0<<ISC01) | (0<<ISC00);
EICRB=(0<<ISC71) | (0<<ISC70) | (0<<ISC61) | (0<<ISC60) | (0<<ISC51) | (0<<ISC50) | (0<<ISC41) | (0<<ISC40);
EIMSK=(0<<INT7) | (0<<INT6) | (0<<INT5) | (0<<INT4) | (0<<INT3) | (0<<INT2) | (0<<INT1) | (0<<INT0);

// USART0 initialization
// Communication Parameters: 8 Data, 1 Stop, No Parity
// USART0 Receiver: On
// USART0 Transmitter: On
// USART0 Mode: Asynchronous
// USART0 Baud Rate: 9600 
UCSR0A=(0<<RXC0) | (0<<TXC0) | (0<<UDRE0) | (0<<FE0) | (0<<DOR0) | (0<<UPE0) | (0<<U2X0) | (0<<MPCM0);
UCSR0B=(1<<RXCIE0) | (1<<TXCIE0) | (0<<UDRIE0) | (1<<RXEN0) | (1<<TXEN0) | (0<<UCSZ02) | (0<<RXB80) | (0<<TXB80);
UCSR0C=(0<<UMSEL0) | (0<<UPM01) | (0<<UPM00) | (0<<USBS0) | (1<<UCSZ01) | (1<<UCSZ00) | (0<<UCPOL0);
UBRR0H=0x00;
UBRR0L=0x33;


// USART1 initialization
// Communication Parameters: 8 Data, 1 Stop, No Parity
// USART1 Receiver: On
// USART1 Transmitter: On
// USART1 Mode: Asynchronous
// USART1 Baud Rate: 115200
UCSR1A=(0<<RXC1) | (0<<TXC1) | (0<<UDRE1) | (0<<FE1) | (0<<DOR1) | (0<<UPE1) | (0<<U2X1) | (0<<MPCM1);
UCSR1B=(1<<RXCIE1) | (1<<TXCIE1) | (0<<UDRIE1) | (1<<RXEN1) | (1<<TXEN1) | (0<<UCSZ12) | (0<<RXB81) | (0<<TXB81);
UCSR1C=(0<<UMSEL1) | (0<<UPM11) | (0<<UPM10) | (0<<USBS1) | (1<<UCSZ11) | (1<<UCSZ10) | (0<<UCPOL1);
UBRR1H=0x00;
UBRR1L=0x33;

// Analog Comparator initialization
// Analog Comparator: Off
// The Analog Comparator's positive input is
// connected to the AIN0 pin
// The Analog Comparator's negative input is
// connected to the AIN1 pin
ACSR=(1<<ACD) | (0<<ACBG) | (0<<ACO) | (0<<ACI) | (0<<ACIE) | (0<<ACIC) | (0<<ACIS1) | (0<<ACIS0);
SFIOR=(0<<ACME);

// ADC initialization
// ADC disabled
ADCSRA=(0<<ADEN) | (0<<ADSC) | (0<<ADFR) | (0<<ADIF) | (0<<ADIE) | (0<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);

// SPI initialization
// SPI disabled
SPCR=(0<<SPIE) | (0<<SPE) | (0<<DORD) | (0<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);

// TWI initialization
// TWI disabled
TWCR=(0<<TWEA) | (0<<TWSTA) | (0<<TWSTO) | (0<<TWEN) | (0<<TWIE);

// Bit-Banged I2C Bus initialization
// I2C Port: PORTD
// I2C SDA bit: 1
// I2C SCL bit: 0
// Bit Rate: 100 kHz
// Note: I2C settings are specified in the
// Project|Configure|C Compiler|Libraries|I2C menu.
i2c_init();

// DS1307 Real Time Clock initialization
// Square wave output on pin SQW/OUT: Off
// SQW/OUT pin state: 0
rtc_init(0,0,0);

// Graphic Display Controller initialization
// The PCD8544 connections are specified in the
// Project|Configure|C Compiler|Libraries|Graphic Display menu:
// SDIN - PORTC Bit 7
// SCLK - PORTA Bit 7
// D /C - PORTC Bit 6
// /SCE - PORTC Bit 5
// /RES - PORTC Bit 4

// Specify the current font for displaying text
glcd_init_data.font=font5x7;
// No function is used for reading
// image data from external memory
glcd_init_data.readxmem=NULL;
// No function is used for writing
// image data to external memory
glcd_init_data.writexmem=NULL;
// Set the LCD temperature coefficient
glcd_init_data.temp_coef=139;
// Set the LCD bias
glcd_init_data.bias=2;
// Set the LCD contrast control voltage VLCD
glcd_init_data.vlcd=69;

glcd_init(&glcd_init_data);

// Global enable interrupts
#asm("sei")
                         
                
RF_Init_RX();
config();
RF_Config_RX();
count = 1;

while(!wifi_connect());

while(!gps_init());

glcd_clear();
                
while (1){
    RF_Mode_RX();                      
                
    if(IRQ == 0){   
        RF_Read_RX_3();     
                     
        print_border();
                    
        if(station_receive.flag == count){
            glcd_moveto(40, 3);
            itoa(station_receive.flag, buff);
            glcd_outtext(buff);                             
            glcd_moveto(46, 18);
            sprintf(buff, "%d ", station_receive.temp);
            glcd_outtext(buff);
            glcd_moveto(46, 28);
            sprintf(buff, "%d ", station_receive.humi);
            glcd_outtext(buff);
            glcd_moveto(46, 37);
            sprintf(buff, "%d  ", station_receive.water);
            glcd_outtext(buff);                
            gps_read(); 
            read_and_send("7U0M5UTEKXE64ZK9");
            delay_ms(800);
            count++;
            if(count == 5)
                count = 1;
            dem = 0;
            TCNT2 = 0x9C;
        }
    }  
                  
    }
              

}
